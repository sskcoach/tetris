# Gemini CLI 바이브 코딩: 프롬프트로 테트리스 만들기

이 문서는 `gemini-cli`와 같은 AI 코딩 어시스턴트와 함께 '바이브 코딩(Vibe-Coding)' 스타일로 소통하며 애플리케이션을 개발하는 과정을 안내합니다. 우리는 구체적인 코드 구현을 지시하는 대신, 원하는 '느낌'과 '기능'을 대화하듯 요청하며 테트리스 게임을 완성했습니다.

이 튜토리얼은 코드 자체보다 **어떤 생각으로 프롬프트를 구성했는지**에 초점을 맞춥니다.

## 바이브 코딩이란?

"Vibe-Coding"은 마이크로서비스 아키텍처를 설계하거나, 특정 라이브러리의 상세한 API 사용법을 지시하는 것이 아닙니다. 대신, 만들고 싶은 것의 '분위기', '느낌', '핵심 동작'을 중심으로 AI에게 요청하는 개발 방식입니다.

-   **"What" vs "How":** "어떻게" 구현할지를 지시하는 대신, "무엇을" 원하는지 설명합니다.
-   **점진적 & 반복적:** 처음부터 완벽한 계획을 세우는 대신, 간단한 요청으로 시작하여 결과물을 보고 계속해서 요구사항을 추가하고 다듬어 나갑니다.
-   **인간 중심적 서술:** "사용자가 'a'키를 누르면 블록의 x 좌표를 1 감소시켜" 라고 말하는 대신, "키보드로 블록을 움직이게 해줘" 라고 말합니다.

## Chapter 1: 첫 아이디어 - "일단 눈에 보이게"

모든 프로젝트는 아주 작은 아이디어에서 시작합니다. 우리의 첫 목표는 '테트리스 블록'이라는 개념을 눈에 보이는 형태로 만드는 것이었습니다.

> **첫 프롬프트 (요약):**
>
> `@tetris.py 테트리스 블록을 1종씩 그리도록 했는데, 옆에 모든 회전된 모습도 같이 보여줘.`

이 요청은 복잡한 데이터 구조나 회전 알고리즘을 전혀 언급하지 않았습니다. 그저 "보여줘"라는 시각적 목표에 집중했습니다. 그 결과, `gemini-cli`는 스스로 다음과 같은 작업을 수행했습니다.

1.  `TETROMINOS` 라는, 블록의 모양을 담은 데이터 구조를 정의.
2.  2차원 배열을 90도 회전시키는 `rotate_clockwise` 함수를 구현.
3.  회전된 블록들을 가로로 나란히 표시하는 출력 로직을 구성.

이처럼, 첫 단계에서는 **최소한의 시각적 목표**를 제시하는 것만으로 충분합니다.

## Chapter 2: 게임의 틀 - "블록이 있을 공간"

블록이 있다면, 그 블록이 떨어질 공간이 필요합니다. 다음은 '게임 보드'라는 개념을 추가하는 과정입니다.

> **프롬프트 (요약):**
>
> `보드를 그려보자. 양쪽 벽은 <| |> 와 같은 형태고. 아래는 ====== 와 \/\/\/ 같은 형식이야. 공백은 . 으로 표시해`

여기서도 우리는 2차원 배열을 만들고, 특정 인덱스에 문자를 할당하라고 지시하지 않았습니다. 대신 원하는 보드의 '모습'과 '스타일'을 직접적으로 묘사했습니다. 이후 `[]` 블록과 `.` 공백의 너비가 맞지 않는 문제를 발견하고, 다음과 같이 프롬프트를 다듬었습니다.

> **후속 프롬프트 (요약):**
>
> `블록이 [] 모양이니까, 빈칸도 너비 2를 차지해야 하지 않나? ' . ' 으로 채워줘.`

이처럼 AI가 만든 초기 결과물을 보고, **마음에 들지 않는 부분을 구체적으로 지적하며 개선**해 나가는 것이 바이브 코딩의 핵심입니다.

## Chapter 3: 생명을 불어넣기 - "움직이게 해줘"

이제 정적인 화면에 움직임을 추가할 차례입니다.

> **프롬프트 (요약):**
>
> `블럭이 천천히 떨어지게 해줘.`

이 간단한 요청에 `gemini-cli`는 게임의 핵심인 **게임 루프(Game Loop)** 개념을 도입했습니다.

1.  `while` 루프를 만들어 시간의 흐름을 구현.
2.  `time.sleep()`으로 일정한 간격을 만들어 '속도'를 제어.
3.  매 루프마다 화면을 지우고 새로 그리는 '애니메이션'의 기본 원리를 적용.
4.  블록의 `y` 좌표를 계속 더해 '중력'을 흉내 냄.

이후, 키보드 입력을 추가하는 과정도 비슷했습니다.

> **프롬프트 (요약):**
>
> `키입력 처리해줘.`
>
> `키입력을 여러번 연타하면 밀리는데, 마지막 입력만 처리해줘.`
>
> `스페이스바를 누르면 맨 아래로 떨어지게 해줘.`

각 프롬프트는 '느려', '밀려' 와 같이 **사용자로서 느끼는 경험**을 전달하거나, '스페이스바를 누르면' 과 같이 **원하는 동작**을 직접적으로 설명합니다. 복잡한 논블로킹 I/O나 입력 버퍼 처리는 AI가 알아서 구현합니다.

## Chapter 4: 게임답게 - "규칙을 만들자"

게임의 재미를 더하는 핵심 규칙들을 추가했습니다.

> **프롬프트 (요약):**
>
> `한줄을 채웠을때, 줄을 비워주는 기능을 만들어줘.`

이 요청을 통해 `check_collision` (충돌 감지)과 `clear_lines` (줄 제거) 라는 게임의 필수 기능이 추가되었습니다. AI는 이 기능을 구현하기 위해 '한 줄이 꽉 찼는지' 어떻게 판단할지, '줄을 지운 후 위에 있던 블록들은 어떻게 처리할지' 등의 세부 로직을 스스로 구성합니다.

## Chapter 5: 큰 그림 그리기 - "구조를 바꾸자"

기능이 많아지면서 코드가 복잡해졌을 때, 우리는 과감하게 전체 구조를 변경하도록 요청했습니다.

> **프롬프트 (요약):**
>
> `SPLASH, TITLE, GAME_STAGE, NEXT_STAGE, GAME_OVER 등으로 SCENE 을 나눠줘.`

이 프롬프트는 특정 코드를 수정하라는 지시가 아닙니다. "게임을 여러 장면으로 나누고 싶다"는 **개념적인 아이디어**를 전달한 것입니다. 그 결과 `gemini-cli`는 다음과 같은 대규모 리팩토링을 수행했습니다.

1.  `Enum`을 사용해 게임의 각 상태(Scene)를 정의.
2.  현재 상태에 따라 적절한 함수를 호출하는 '상태 머신' 패턴을 메인 루프에 도입.
3.  기존의 게임 로직을 `run_game` 함수로 캡슐화.
4.  `run_splash_screen`, `run_title_screen` 등 각 장면에 맞는 함수들을 생성.

## 결론: 프롬프트의 기술

`gemini-cli`와의 바이브 코딩은 명령이 아닌 '소통'에 가깝습니다.

-   **크게 시작하세요:** "테트리스 만들어줘"
-   **경험을 묘사하세요:** "너무 빨라", "깜박거려", "레트로 느낌이 나면 좋겠어"
-   **원하는 것을 말하세요:** "미리보기를 추가해줘", "줄이 꽉 차면 사라지게 해줘"
-   **AI를 믿으세요:** 세부 구현은 AI에게 맡기고, 당신은 게임의 '재미'와 '방향성'을 결정하는 디렉터가 되면 됩니다.

이러한 개발 방식은 코드 작성에 대한 부담을 줄이고, 아이디어를 빠르게 프로토타입으로 만드는 데 매우 효과적입니다.
